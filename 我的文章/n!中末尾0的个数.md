#### 分析

```
1、2、3、4、5、6、7、8、9、10、11、...
```

- 1

1、分析上面的数列可知，每5个数中会出现一个可以产生结果中0的数字。把这些数字抽取出来是：

```
...、5、...、10、...、15、...、20、...、25、...
```

- 1

这些数字其实是都能满足`5*k`的数字，是5的倍数。统计一下他们的数量：`n1=N/5`。比如如果是101，则101之前应该是`5,10,15,20,...,95,100`共`101/5=20`个数字满足要求。

> 整除操作满足上面的数量统计要求。

2、将`1`中的这些数字化成`5*(1、2、3、4、5、...)`的形式，内部的`1、2、3、4、5、...`又满足上面的分析：每5个数字有一个是5的倍数。抽取为：

```
...、25、...、50、...、75、...、100、...、125、...
```

- 1

而这些数字都是25的倍数（5的2次幂的倍数），自然也都满足`5*k`的要求。
这些数字是`25、50、75、100、125、...=5*(5、10、15、20、25、...)=5*5*(1、2、3、4、5、...)`，内部的`1、2、3、4、5、...`又满足上面的分析，因此后续的操作重复上述步骤即可。
统计一下第二次中满足条件的数字数量：`n2=N/5/5`，`101/25=(101/5)/5=4`。
因为`25、50、75、100、125、...`它们都满足相乘后产生至少两个0，在第一次`5*k`分析中已经统计过一次。对于`N=101`，是20。因此此处的`5*5*k`只要统计一次4即可，不需要根据25是5的二次幂统计两次。
后面的`125,250,...`等乘积为1000的可以为结果贡献3个0的数字，只要在`5*5*k`的基础上再统计一次`n3=((N/5)/5)/5`即可。
![阶乘尾部的0的个数](https://img-blog.csdn.net/20160416152912230)

3、第三次
其实到这里已经不用再写，规律已经很清楚了。对于例子`N=101`，只要根据规律进行`101/125=((101/5)/5)/5=4/5=0`，退出统计。因此最终结果是`20+4=24`。计算结束。

#### 算法3代码

下面编写打码实现上面的思想。

```java
public class Solution {     /*     * param n: As desciption return: An integer, denote the number of trailing     * zeros in n!     */    public long trailingZeros(long n) {        // write your code here        long count = 0;        long temp=n/5;        while (temp!=0) {            count+=temp;            temp/=5;        }        return count;    }}
```