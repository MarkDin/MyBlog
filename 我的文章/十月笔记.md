# 十月笔记

## python中range用法

python range() 函数可创建一个整数列表，一般用在 for 循环中。

#### 函数语法

```
range(start, stop[, step])
```

#### 参数说明：

- start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;
- stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5
- step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)

#### 实例

```python
range(0, 30, 5) # 步长为 5
[0, 5, 10, 15, 20, 25]
range(0, -10, -1) # 负数
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
range(9, 0, -1) # 逆序
[9, 8, 7, 6, 5, 4, 3, 2, 1]
```

###死锁防止：
破除互斥等待：一般无法破除
破除hold and wait：一次性获取所有资源
破除循环等待：按顺序获取资源
破除无法剥夺的等待：加入超时
（死锁：同时满足这4个条件

###题目
struct temp{

​    short a;

​    char  b;

​    char c ;

​    long d;

​    char e;

​    int f;

};在32位机器上sizeof的大小. 

32位机器按4字节补齐，62位机器下按8字节补齐

1.总字节数是下一个类型字节的整数倍，如果不是则补齐

2.long long型按四字节补齐，8字节计算‘

3.最后结构体的大小是最宽字节的整数倍(32位最字节是4,64最宽字节是8)

所以最后答案就是2+1+1+4+1+（3，补齐到4，前面的字节和是9，是后面字节类型的整数倍，所以+3）+4

### 降低Cache失效率的方法

许多相关Cache的研究都致力于降低Cache的失效率。这里就讨论这个！

按照产生失效的原因不同，可以把失效分为以下3类（简称为"3C"）:

(1). 强制性失效 (Compulsory miss): 当第一次访问一个块时，该块不在 Cache中, 需从下一级存储中调入 Cache, 这就是强制性失效。这种失效也称为冷启动失效，或首次访问失效。(增加块大小，预取)

(2). 容量失效 (Capacity miss): 如果程序执行时所需的块不能全部调入 Cache 中, 则当某些块被替换后, 若又重新被访问, 就会发生失效。这种失效称为容量失效。(增加容量) 抖动现象。

(3). 冲突失效 (Conflict miss): 在组相联或直接映像 Cache 中, 若太多的块映像到同一组(块)中，则会出现改组中某个块被别的块替换、然后又被重新访问的情况。这就是发生了冲突失效。这种失效也称为碰撞失效 (collision) 或干扰失效 (interference)。(提高相联度)

SPEC92基础测试程序给出了这三种失效在不同容量不同相联度下的失效率情况略。总结的情况如下：

(1) 相联度越高，冲突失效就越少。

(2) 强制性失效和容量失效不受相联度的影响。

(3) 强制性生效不受 Cache 容量的影响，但容量失效却随着容量的增加而减少。

(4) 表中的数据符合 2:1 的 Cache 经验规则，即大小为N的直接映像 Cache 的失效率约等于大小为 N/2 的 2 路组相联 Cache 的失效率。



编译器优化
前面所介绍的技术(增加块大小、增加Cache容量、提高相联度、伪相联、硬件预取以及预取指令等)都需要改变或者增加硬件。下面介绍的方法，无需对硬件做任何改动就可以降低失效率。或许，这也是能对我们的程序效率有帮助的地方！

我们能很容易地重新组织程序而不影响程序的正确性。例如，把一个程序中的几个过程重新排序，就可能会减少冲突失效，从而降低指令失效率。McFarling研究了如何使用记录信息来判断指令组之间可能发生的冲突，并将指令重新排序以减少失效。他发现，这样可将容量为2KB、块大小为4KB的直接映像指令Cache的失效率降低50%；对于容量为8KB的 Cache，可将失效率降低75%。他还发现当能够是某些指令根本就不进入 Cache 时，可以得到最佳性能。但即使不这么做，优化后的程序在直接映像 Cache 中的失效率也低于未优化程序在同样大小的8路组相联映像 Cache 中的失效率。

数据对存储位置的限制比指令对存储位置的限制还要少，因此更便于调整顺序。我们对数据进行变换的目的是改善数据的空间局部性和时间局部性。例如，可以把对数据的运算改为对存放在同一 Cache 块中的所有数据进行操作，而不是按照程序员原来随意书写的顺序访问数组元素。

1. 数组合并 ( merging arrays )
这种技术通过提高空间局部性来减少失效次数。有些程序同时用相同的索引来访问若干数组中的同一维。这些访问可能会相互干扰，导致冲突失效。我们可以这样来消除这种危险：将这些相互独立的数组合并成为一个复合数组，使得一个 Cache 块中能包含全部所需的元素。

/* 修改前 */



/* 修改后 */



这个例子有一个有趣的特点：如果程序员能正确地使用记录数组，他就能获得与本优化相同的益处。

2. 内外循环交换 ( loop interchange )
有些程序中含有嵌套循环，程序没有按照数据在存储器中存储的顺序进行访问。在这种情况下，只要简单地交换循环的嵌套关系，就能使程序按数据在存储器中存储的顺序进行访问。和前一个例子一样，这种技术也是通过提高空间局部性来减少失效次数，重新排列访问顺序使得在一个 Cache 块被替换之前，能最大限度地利用块中的数据。

/* 修改前 */



/* 修改后 */



修改前程序以100个字的跨距访问存储器，而修改后的程序顺序地访问一个 Cache 块中的元素，然后再访问下一块中的元素。这种优化技术在不改变执行的指令条数的前提下，提高了 Cache 的性能。

简单测试:



编译: 

> gcc -Wall a.c -o a

> gcc -Wall b.c -o b

结果: //没看CPU的情况,看起来貌似有效。。。



3. 循环融合 ( loop fusion )
有些程序含有几部分独立的程序段，它们用相同的循环访问同样的数组，对相同的数据做不同的运算。通过将它们融合为单一的循环，能使读入 Cache 的数据在被替换出去之前，得到反复的使用。和前面的两种技术不同，这种优化的目标是通过改进时间局部性来减少失效次数。

/* 修改前 */



/* 修改后 */



修改前的程序在两个地方访问数组a 和 c，一次是在第一个循环里，另一次是在第二个循环里。两次循环分隔较远，可能会产生重复失效，即在第一个循环中访问某个元素失效之后，虽已将相应块调入 Cache，但在第二个循环中再次访问该元素时，还可能产生失效。而在修改后的程序中，第二条语句直接利用了第一条语句访问 Cache 的结果，无需再到存储器去取。



4. 分块
这种优化可能是 Cache 优化技术中最著名的一种，它也是通过改进时间局部性来减少时效。下面仍考虑对多个数组的访问，有些数组是按行访问，而有些规则是按列访问。无论数组是按行优先还是按列优先存储，都不能解决问题，因为在每一次循环中既有按行访问也有按列访问。这种正交的访问意味着前面的变换方法，如内外循环交换，对此军无能为力。

分块算法不是对数组的整行或整列进行访问，而是对子矩阵或块进行操作。其目的仍然是使一个 Cache 块在被替换之前，对它的访问次数达到最多。下面这个矩阵乘法程序有助于我们理解为什么要采用这种优化技术。

### 概率和大数据面试题

#### 题目:给定一个长度为N的数组arr,和一个整数M,请你用函数等概率的打印出M个数

#### 解法:先打印第i个位置的数,然后将数组最后一个数与其交换, 即在数组尾部维护一个失效的数字区,这个区域的数已经打印过了

题目:将十亿个ip地址进行排序

解法: 创建一个长度为2的32次方的bitmap,初始化值都为0,然后将IP地址对应的整数在bitmap对应的下标位置涂黑

### python中的IO

#### 以不同的分隔符或行结尾符完成打印

```python
print('a', 12, sep=',')
```

#### 将输出重定向到文件中

只需要为print()函数加上file关键字参数即可:

```python
with open() as f:
    print('Hello World', file=f)
```

#### 读写二进制数据

使用open()函数的rb或者wb模式就可以实现对二进制数据的读写

```python
with open('somefile.bin', 'rb') as f:
    data = f.read()
```

当读取二进制数据时, 很重要的一点是所有的数据将以字节串的形式返回, 而不是文本字符串.

同样的, 当写入二进制数据时, 数据必须是以对象的形式来提供, 而且该对象可以将数据以字节形式暴露出来

#### 对已不存在的文件执行写入操作

问题: 我们想将数据写入到一个文件中, 但只在该文件不在系统中时才这么做.

解决: 通过使用open()函数中鲜为人知的x模式代替常见的w模式来解决.:

```python
with open('somefile.bin', 'wt') as f:
    f.write('Hello')
    
with open('somefile.bin', 'xt') as f:
    f.write('Hello')    
```

上面第二次使用xt模式写入数据时就会报`FileExistsError`, 因为somefile.bin已经存在了

也可以先检查文件是否存在:

```python
import os
if not os.path.exists('somefile'):
	with open('somefile', 'wt'):
		f.write('')
else:
	print('File already exists!')
```

#### 在字符串上执行I/O操作

问题: 我们想将一段文本或二进制字符串写入类似于文件的对象上.

解决: 使用io.StringIO()和io.ByteIO()类来创建类似于文件的对象, 这些对象可操作字符串数据.

```python
s = io.StringIO()
s.write('Hello\n')
# 输出到s
print('This is a test\n', file=s)
# 获取目前的所有写入数据
s.getvalue()
# 'Hello\nThis is a test\n'
# Wrap a file interface around an exsiting string
s = os.StringIO('hell0\nWorld\n')
s.read(4)
# 'Hell'
```

如果要操作二进制数据, 请使用io.ByteIO()

#### 读写压缩文件

gzip和bz2木块都提供了open()的其他实现, 用于处理压缩文件, 将压缩文件以文本形式读取,可以这样:

```
import gzip
with gzip.open('somefile.gz', 'wt'):
	text = f.read()
```

## python中iter()的用法

iter() 方法其实是接受两个参数的，文档说明如下

> iter(object[, sentinel])
>
> sentinel 英文翻译为 哨兵。

### 当存在sentinel参数时

sentinel 参数是可选的，当它存在时，object 不再传入一个可迭代对象，而是一个可调用对象，通俗点说就是可以通过()调用的对象，而 sentinel 的作用就和它的翻译一样，是一个“哨兵”，当时可调用对象返回值为这个“哨兵”时，循环结束，且不会输出这个“哨兵”。

##### 举例:

心里想一个[1, 10]范围的数，然后代码开始随机，当随机到想的数时停止，看每次代码需要随机几次。

实现分析：看起来应该很简单，random，然后加一个if判断即可，但是用 iter() 来实现更简单。实现代码如下：

```python
`from` `random ``import` `randint``def` `guess():`` ``return` `randint(``0``, ``10``)``num ``=` `1``# 这里先写死心里想的数为5``for` `i ``in` `iter``(guess, ``5``):`` ``print``(``"第%s次猜测，猜测数字为: %s"` `%` `(num, i))`` ``num ``+``=` `1``# 当 guess 返回的是 5 时，会抛出异常 StopIteration，但 for 循环会处理异常，即会结束循环`
```

### 当只传入一个参数时

如果没有第二个参数，object（即第一个参数）是一个支持迭代器协议（实现_iter_()方法的）的集合对象，或者是支持序列协议（实现_getitem_()方法）且是从0开始索引。如果它不支持其中任何一个，则抛出 TypeError 异常

简单来说就是，如果没有第二个参数，就是我们比较熟悉的用法。代码示例如下：

```python
In [5]: iter("123")
Out[5]: <str_iterator at 0x105c9b9e8>
In [6]: iter([1, 2, 3])
Out[6]: <list_iterator at 0x105f9f8d0>
In [7]: iter(123)
---------------------------------------------------------------------------
TypeError Traceback (most recent call last)
<ipython-input-7-c76acad08c3c> in <module>()
----> 1 iter(123)
TypeError: 'int' object is not iterable
```

如果给定了第二个参数 sentinel，object 则必须是一个可调用对象，这个可调用对象没有任何参数，当可调用对象的返回值等于 sentinel 的值时，抛出 StopIteration 的异常，否则返回当前值。（这里如果不好理解可调用对象，可以理解为函数，这样更容易想明白）

### 小结一下

1、iter() 方法不管有没有第二个参数，返回的都是迭代器

2、iter() 方法第一个参数的参数类型，根据有无第二个参数决定

3 、有第二个参数时的一个应用场景就是创建一个 blokc-reader，即根据条件中断读取。比如：从二进制数据库文件读取固定宽度的块，直到到达文件的末尾，代码示例如下：

```python
from functools import partial
with open('mydata.db', 'rb') as f:
 	for block in iter(partial(f.read, 64), b''):
 	process_block(block)
```

## python中format

format是python2.6新增的一个格式化字符串的方法，相对于老版的%格式方法，它有很多优点。

1.不需要理会数据类型的问题，在%方法中%s只能替代字符串类型

2.单个参数可以多次输出，参数顺序可以不相同

3.填充方式十分灵活，对齐方式十分强大

4.官方推荐用的方式，%方式将会在后面的版本被淘汰

format的一个例子

```python
print 'hello {0}'.format('world')
# hello world   
```

5.叹号的用法

！后面可以加s r a 分别对应str() repr() ascii()

作用是在填充前先用对应的函数来处理参数

```python
print "{!s}".format('2')  
#  2

print "{!r}".format('2')   
# '2'
```

差别就是repr带有引号，str()是面向用户的，目的是可读性，repr()是面向python解析器的，返回值表示在python内部的含义

ascii()一直报错，可能这个是3.0才有的函数