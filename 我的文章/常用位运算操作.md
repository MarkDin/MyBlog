# 常用位运算操作

#### 正数的相反数求法:将正数的补码按位取反(符号位也取反),然后加一
#### 正数的反码是其本身
#### 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反
#### 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

### 1. i+(~i)=-1展开目录

i 取反再与 i 相加，相当于把所有二进制位设为 1，其十进制结果为 - 1。

### 2. 计算 n+1 与 n-1展开目录

`-~n == n + 1`，~n 为其取反，负号 '-' 再对其取反并加 1。

`~-n == n - 1`，思路就是找到最低位的第一个 1，对其取反并把该位后的所有位也取反，即`01001000`变为`01000111`。

### 3. 取相反数展开目录

思路就是取反并加 1，也即`~n + 1`或者`(n ^ -1) + 1`。

### 8. 判断奇偶性展开目录

```cpp
/* 判断是否是奇数 */
bool is_odd(int n)
{
    return (n & 1 == 1);
}
```

### 9. 不用临时变量交换两个数展开目录

```cpp
/* 此方法对 a 和 b 相等的情况不适用 */
a ^= b;  
b ^= a;  // 相当于 b = b ^ ( a ^ b );
a ^= b;
```

### 13. 判断一个数是不是 2 的幂展开目录

```cpp
bool is_power_of_two(int n)
{
    return (n > 0) ? (n & (n - 1)) == 0 : false;
}  
```

1.求下面函数的返回值（微软）

int func(x)
{
int countx = 0;
while(x)
{
countx ++;
x = x&(x-1);
}
return countx;
}

假定x = 9999。 答案：8

这个问题或许你见过，如果从最后一个1的角度思考，或许你更容易接受。

X&(x-1)是什么意思，按照前面的思考，这个动作会将x的最后一个1给置0，所以，每做一次这样的动作（x = x&(x-1);）就会导致，x从右到左，少一个1。最后，当左右的x的1都没有的时候while（x）循环跳出，

所以，答案和x的二进制有多少1是一致的。

所以，我们在做类似的问题的时候要知道，位运算通常会在最后一个1，会者是0上找到规律。